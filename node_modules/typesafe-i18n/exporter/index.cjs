'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var path = require('path');
var fs = require('fs');
var url = require('url');
var ts = require('typescript');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
	if (e && e.__esModule) return e;
	var n = Object.create(null);
	if (e) {
		Object.keys(e).forEach(function (k) {
			if (k !== 'default') {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () { return e[k]; }
				});
			}
		});
	}
	n["default"] = e;
	return Object.freeze(n);
}

var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var ts__default = /*#__PURE__*/_interopDefaultLegacy(ts);
var ts__namespace = /*#__PURE__*/_interopNamespace(ts);

let FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, isTTY=true;
if (typeof process !== 'undefined') {
	({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env);
	isTTY = process.stdout && process.stdout.isTTY;
}

const $ = {
	enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== 'dumb' && (
		FORCE_COLOR != null && FORCE_COLOR !== '0' || isTTY
	),

	// modifiers
	reset: init(0, 0),
	bold: init(1, 22),
	dim: init(2, 22),
	italic: init(3, 23),
	underline: init(4, 24),
	inverse: init(7, 27),
	hidden: init(8, 28),
	strikethrough: init(9, 29),

	// colors
	black: init(30, 39),
	red: init(31, 39),
	green: init(32, 39),
	yellow: init(33, 39),
	blue: init(34, 39),
	magenta: init(35, 39),
	cyan: init(36, 39),
	white: init(37, 39),
	gray: init(90, 39),
	grey: init(90, 39),

	// background colors
	bgBlack: init(40, 49),
	bgRed: init(41, 49),
	bgGreen: init(42, 49),
	bgYellow: init(43, 49),
	bgBlue: init(44, 49),
	bgMagenta: init(45, 49),
	bgCyan: init(46, 49),
	bgWhite: init(47, 49)
};

function run(arr, str) {
	let i=0, tmp, beg='', end='';
	for (; i < arr.length; i++) {
		tmp = arr[i];
		beg += tmp.open;
		end += tmp.close;
		if (!!~str.indexOf(tmp.close)) {
			str = str.replace(tmp.rgx, tmp.close + tmp.open);
		}
	}
	return beg + str + end;
}

function chain(has, keys) {
	let ctx = { has, keys };

	ctx.reset = $.reset.bind(ctx);
	ctx.bold = $.bold.bind(ctx);
	ctx.dim = $.dim.bind(ctx);
	ctx.italic = $.italic.bind(ctx);
	ctx.underline = $.underline.bind(ctx);
	ctx.inverse = $.inverse.bind(ctx);
	ctx.hidden = $.hidden.bind(ctx);
	ctx.strikethrough = $.strikethrough.bind(ctx);

	ctx.black = $.black.bind(ctx);
	ctx.red = $.red.bind(ctx);
	ctx.green = $.green.bind(ctx);
	ctx.yellow = $.yellow.bind(ctx);
	ctx.blue = $.blue.bind(ctx);
	ctx.magenta = $.magenta.bind(ctx);
	ctx.cyan = $.cyan.bind(ctx);
	ctx.white = $.white.bind(ctx);
	ctx.gray = $.gray.bind(ctx);
	ctx.grey = $.grey.bind(ctx);

	ctx.bgBlack = $.bgBlack.bind(ctx);
	ctx.bgRed = $.bgRed.bind(ctx);
	ctx.bgGreen = $.bgGreen.bind(ctx);
	ctx.bgYellow = $.bgYellow.bind(ctx);
	ctx.bgBlue = $.bgBlue.bind(ctx);
	ctx.bgMagenta = $.bgMagenta.bind(ctx);
	ctx.bgCyan = $.bgCyan.bind(ctx);
	ctx.bgWhite = $.bgWhite.bind(ctx);

	return ctx;
}

function init(open, close) {
	let blk = {
		open: `\x1b[${open}m`,
		close: `\x1b[${close}m`,
		rgx: new RegExp(`\\x1b\\[${close}m`, 'g')
	};
	return function (txt) {
		if (this !== void 0 && this.has !== void 0) {
			!!~this.has.indexOf(open) || (this.has.push(open),this.keys.push(blk));
			return txt === void 0 ? this : $.enabled ? run(this.keys, txt+'') : txt+'';
		}
		return txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt+'') : txt+'';
	};
}

const parseTypescriptVersion = (versionMajorMinor) => {
    const [major, minor] = versionMajorMinor.split('.').map((item) => +item);
    return {
        major,
        minor,
    };
};
class TypesafeI18nParseError extends Error {
}
const colorMap = {
    warn: 'yellow',
    error: 'red',
};
const colorize = (logLevel, ...messages) => logLevel === 'info' ? messages : [$[colorMap[logLevel]]().bold(messages.join(' '))];
const log = (console, logLevel, ...messages) => console[logLevel](...colorize(logLevel, '[typesafe-i18n]', ...messages));
const throwError = (console, logLevel, ...messages) => {
    log(console, logLevel, ...messages);
    throw new TypesafeI18nParseError();
};
const createLogger = (console, throwOnError = false) => ({
    info: log.bind(null, console, 'info'),
    warn: log.bind(null, console, 'warn', 'WARNING:'),
    error: (throwOnError ? throwError : log).bind(null, console, 'error', 'ERROR:'),
});
const logger$1 = createLogger(console);

const isTruthy = (value) => !!value;

let outputFormat = 'TypeScript';
let tsVersion = parseTypescriptVersion('4.3');
const configureOutputHandler = (config, version) => {
    outputFormat = config.outputFormat;
    shouldGenerateJsDoc = outputFormat === 'JavaScript';
    fileEnding = shouldGenerateJsDoc ? '.js' : '.ts';
    tsVersion = version;
    shouldGenerateJsDoc || (tsVersion.major === 4 && tsVersion.minor >= 1) || tsVersion.major >= 5;
    shouldGenerateJsDoc || (tsVersion.major === 3 && tsVersion.minor >= 8) || tsVersion.major >= 4;
};
let shouldGenerateJsDoc;
let fileEnding;

const { readFile: read, readdir, writeFile, mkdir, stat, rm } = fs.promises;
// --------------------------------------------------------------------------------------------------------------------
// implementation -----------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------
const readFile = async (file, createPath = false) => {
    var _a;
    try {
        if (createPath) {
            await createPathIfNotExits(path.resolve(path.dirname(file)));
        }
        return (_a = (await read(file))) === null || _a === void 0 ? void 0 : _a.toString();
    }
    catch (_e) {
        return createPath ? '' : readFile(file, true);
    }
};
const doesPathExist = async (path) => {
    try {
        await stat(path);
        return true;
    }
    catch (_e) {
        return false;
    }
};
const createPath = async (path) => {
    try {
        await mkdir(path, { recursive: true });
        return true;
    }
    catch (e) {
        logger$1.error(`createPath: ${path}`, e);
        return false;
    }
};
const createPathIfNotExits = async (path) => {
    const pathExists = await doesPathExist(path);
    if (!pathExists) {
        await createPath(path);
    }
};
const deleteFolderRecursive = async (path) => {
    try {
        await rm(path, { recursive: true });
        return true;
    }
    catch (e) {
        logger$1.error(`deleteFolderRecursive: ${path}`, e);
        return false;
    }
};
const getFiles = async (path$1, depth = 0) => {
    const entries = await readdir(path$1, { withFileTypes: true });
    const files = entries.filter((file) => !file.isDirectory()).map(({ name }) => ({ name, folder: '' }));
    const folders = entries.filter((folder) => folder.isDirectory());
    if (depth) {
        for (const folder of folders)
            files.push(...(await getFiles(`${path.resolve(path$1, folder.name)}/`, depth - 1)).map((a) => ({
                ...a,
                folder: folder.name,
            })));
    }
    return files;
};
const containsFolders = async (path) => {
    const entries = await readdir(path, { withFileTypes: true });
    return entries.some((folder) => folder.isDirectory());
};
const getDirectoryStructure = async (path$1) => {
    const entries = await readdir(path$1, { withFileTypes: true });
    const folders = entries.filter((folder) => folder.isDirectory());
    const promises = folders.map(({ name }) => new Promise((r) => getDirectoryStructure(path.resolve(path$1, name)).then((x) => r([name, x]))));
    return Object.fromEntries(await Promise.all(promises));
};
const isWindows = process.platform === 'win32';
const isEsm = ((typeof document === 'undefined' ? new (require('u' + 'rl').URL)('file:' + __filename).href : (document.currentScript && document.currentScript.src || new URL('index.cjs', document.baseURI).href)) || '').endsWith('.mjs');
const importFile = async (file, outputError = true) => {
    var _a;
    if (file.endsWith('.json')) {
        const jsonFile = await readFile(file);
        return jsonFile ? JSON.parse(jsonFile) : undefined;
    }
    const importPath = isWindows && isEsm ? url.pathToFileURL(file).href : file;
    return (_a = (await (function (t) { return Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require(t)); }); })(importPath).catch((e) => {
        outputError && logger$1.error(`import failed for ${importPath}`, e);
        return null;
    }))) === null || _a === void 0 ? void 0 : _a.default;
};

// --------------------------------------------------------------------------------------------------------------------
[
    'boolean',
    'number',
    'bigint',
    'string',
    'Date',
    'object',
    'undefined',
    'null',
    'unknown',
    'LocalizedString',
].flatMap((t) => [t, `${t}[]`]);

// --------------------------------------------------------------------------------------------------------------------
// implementation -----------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------
const readConfig = async (config) => {
    const generatorConfig = {
        ...config,
        ...((await importFile(path__default["default"].resolve('.typesafe-i18n.json'), false)) || {}),
    };
    // remove "$schema" property
    return Object.fromEntries(Object.entries(generatorConfig).filter(([key]) => key !== '$schema'));
};
const getConfigWithDefaultValues = async (config) => ({
    baseLocale: 'en',
    locales: [],
    tempPath: './node_modules/typesafe-i18n/temp-output/',
    outputPath: './src/i18n/',
    outputFormat: 'TypeScript',
    typesFileName: 'i18n-types',
    utilFileName: 'i18n-util',
    formattersTemplateFileName: 'formatters',
    typesTemplateFileName: 'custom-types',
    esmImports: false,
    loadLocalesAsync: true,
    generateOnlyTypes: false,
    banner: '/* eslint-disable */',
    ...(await readConfig(config)),
});

/**
 * looks for the location of the compiled 'index.js' file
 * if the 'index.ts' file imports something from outside it's directory, we need to find the correct path to the base location file
 */
const detectLocationOfCompiledBaseTranslation = async (outputPath, locale, tempPath) => {
    if (!containsFolders(tempPath))
        return '';
    const directory = await getDirectoryStructure(tempPath);
    // contains the path from <root> to base locale file
    const outputPathParts = path.resolve(outputPath, locale).replace(path.resolve(), '').split(path.sep).filter(isTruthy);
    for (let i = 0; i < outputPathParts.length; i++) {
        const part = outputPathParts[i];
        const subDirectory = directory[part];
        if (subDirectory) {
            let outputPathPartsRest = [...outputPathParts].slice(i + 1);
            let isPathValid = true;
            let subDirectoryOfCurrentSection = subDirectory;
            const subPaths = [part];
            while (isPathValid && outputPathPartsRest.length) {
                // we need to find the full matching path
                // e.g. `src/path/i18n/en` is invalid if the base locale is located inside `src/i18n/en`
                const subSubDirectoryOfCurrentSection = subDirectoryOfCurrentSection[outputPathPartsRest[0]];
                if (subSubDirectoryOfCurrentSection) {
                    subPaths.push(outputPathPartsRest[0]);
                    outputPathPartsRest = outputPathPartsRest.slice(1);
                    subDirectoryOfCurrentSection = subSubDirectoryOfCurrentSection;
                }
                else {
                    isPathValid = false;
                }
            }
            if (isPathValid) {
                i += outputPathPartsRest.length;
                return [...subPaths, ''].join('/');
            }
        }
    }
    return '';
};
const transpileTypescriptFiles = async (outputPath, languageFilePath, locale, tempPath) => {
    const program = ts__default["default"].createProgram([languageFilePath], { outDir: tempPath, allowJs: true });
    program.emit();
    const baseTranslationPath = await detectLocationOfCompiledBaseTranslation(outputPath, locale, tempPath);
    return path.resolve(tempPath, `${baseTranslationPath}index.js`);
};
const parseLanguageFile = async (outputPath, locale, tempPath) => {
    const originalPath = path.resolve(outputPath, locale, `index${fileEnding}`);
    if (!(await doesPathExist(originalPath))) {
        logger$1.info(`could not load base locale file '${locale}'`);
        return null;
    }
    await createPathIfNotExits(tempPath);
    const importPath = await transpileTypescriptFiles(outputPath, originalPath, locale, tempPath);
    if (!importPath) {
        return null;
    }
    const languageImport = await importFile(importPath);
    await deleteFolderRecursive(tempPath);
    if (!languageImport) {
        logger$1.error(`could not read default export from language file '${locale}'`);
        return null;
    }
    return languageImport;
};
const getAllLanguages = async (path) => {
    const files = await getFiles(path, 1);
    return files.filter(({ folder, name }) => folder && name === `index${fileEnding}`).map(({ folder }) => folder);
};

const logger = createLogger(console, true);
// --------------------------------------------------------------------------------------------------------------------
const setup = async () => {
    const config = await getConfigWithDefaultValues();
    const version = parseTypescriptVersion(ts__namespace.versionMajorMinor);
    configureOutputHandler(config, version);
    return config;
};
const readTranslation = async (locale, outputPath, tempPath) => {
    logger.info(`exporting translations for locale '${locale}' ...`);
    const translations = await parseLanguageFile(outputPath, locale, path.resolve(tempPath, locale));
    if (!translations) {
        logger.error(`could not find locale file '${locale}'`);
    }
    logger.info(`exporting translations for locale '${locale}' completed`);
    return { locale, translations: translations };
};
// --------------------------------------------------------------------------------------------------------------------
const readTranslationFromDisk = async (locale) => {
    const config = await setup();
    const { outputPath, tempPath } = config;
    return (await readTranslation(locale, outputPath, tempPath)).translations;
};
// --------------------------------------------------------------------------------------------------------------------
const readTranslationsFromDisk = async () => {
    const config = await setup();
    const { outputPath, tempPath } = config;
    const locales = await getAllLanguages(outputPath);
    const promises = locales.map((locale) => readTranslation(locale, outputPath, tempPath));
    return Promise.all(promises);
};

exports.readTranslationFromDisk = readTranslationFromDisk;
exports.readTranslationsFromDisk = readTranslationsFromDisk;
//# sourceMappingURL=index.cjs.map
