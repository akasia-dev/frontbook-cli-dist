// --------------------------------------------------------------------------------------------------------------------
// implementation -----------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------
const isPluralPart = (part) => !!(part.o || part.r);
const applyFormatters = (formatters, formatterKeys, value) => formatterKeys.reduce((prev, formatterKey) => { var _a, _b; return (_b = (_a = formatters[formatterKey]) === null || _a === void 0 ? void 0 : _a.call(formatters, prev)) !== null && _b !== void 0 ? _b : prev; }, value);
const getPlural = (pluraRules, { z, o, t, f, m, r }, value) => {
    switch (z && value == 0 ? 'zero' : pluraRules.select(value)) {
        case 'zero':
            return z;
        case 'one':
            return o;
        case 'two':
            return t;
        case 'few':
            return f;
        case 'many':
            return m;
        default:
            return r;
    }
};
const REGEX_PLURAL = /\?\?/g;
const applyArguments = (textParts, pluralRules, formatters, args) => textParts
    .map((part) => {
    if (typeof part === 'string') {
        return part;
    }
    const { k: key = '0', f: formatterKeys = [] } = part;
    const value = args[key];
    if (isPluralPart(part)) {
        return ((typeof value === 'boolean' ? (value ? part.o : part.r) : getPlural(pluralRules, part, value)) || '').replace(REGEX_PLURAL, value);
    }
    const formattedValue = formatterKeys.length ? applyFormatters(formatters, formatterKeys, value) : value;
    return ('' + (formattedValue !== null && formattedValue !== void 0 ? formattedValue : '')).trim();
})
    .join('');
const translate = (textParts, pluralRules, formatters, args) => {
    const firstArg = args[0];
    const isObject = firstArg && typeof firstArg === 'object' && firstArg.constructor === Object;
    const transformedArgs = (args.length === 1 && isObject ? firstArg : args);
    return applyArguments(textParts, pluralRules, formatters, transformedArgs);
};

const removeEmptyValues = (object) => Object.fromEntries(Object.entries(object)
    .map(([key, value]) => key !== 'i' && value && value != '0' && [key, value])
    .filter(Boolean));
const trimAllValues = (part) => Object.fromEntries(Object.keys(part).map((key) => {
    var _a;
    const val = part[key];
    return [
        key,
        Array.isArray(val) ? val.map((v) => v === null || v === void 0 ? void 0 : v.trim()) : val === !!val ? val : (_a = val) === null || _a === void 0 ? void 0 : _a.trim(),
    ];
}));
const getFallbackProxy = (prefixKey) => new Proxy((prefixKey ? () => prefixKey : {}), {
    get: (_target, key) => getFallbackProxy(prefixKey ? `${prefixKey}.${key}` : key),
});

// --------------------------------------------------------------------------------------------------------------------
// implementation -----------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------
const REGEX_BRACKETS_SPLIT = /({?{[^\\}]+}}?)/g;
const parseArgumentPart = (text) => {
    const [keyPart = '', ...formatterKeys] = text.split('|');
    const [keyWithoutType = '', type] = keyPart.split(':');
    const [key, isOptional] = keyWithoutType.split('?');
    return { k: key, i: type, n: isOptional === '', f: formatterKeys };
};
const parsePluralPart = (content, lastAccessor) => {
    let [key, values] = content.split(':');
    if (!values) {
        values = key;
        key = lastAccessor;
    }
    const entries = values.split('|');
    const [zero, one, two, few, many, rest] = entries;
    const nrOfEntries = entries.filter((entry) => entry !== undefined).length;
    if (nrOfEntries === 1) {
        return { k: key, r: zero };
    }
    if (nrOfEntries === 2) {
        return { k: key, o: zero, r: one };
    }
    if (nrOfEntries === 3) {
        return { k: key, z: zero, o: one, r: two };
    }
    return { k: key, z: zero, o: one, t: two, f: few, m: many, r: rest };
};
const parseRawText = (rawText, optimize = true, firstKey = '', lastKey = '') => rawText
    .split(REGEX_BRACKETS_SPLIT)
    .filter(Boolean)
    .map((part) => {
    if (!part.match(REGEX_BRACKETS_SPLIT)) {
        return part;
    }
    const content = part.substring(1, part.length - 1);
    if (content.startsWith('{') && content.endsWith('}')) {
        return parsePluralPart(content.substring(1, content.length - 1), lastKey);
    }
    const parsedPart = parseArgumentPart(content);
    lastKey = parsedPart.k || lastKey;
    !firstKey && (firstKey = lastKey);
    return parsedPart;
})
    .map((part) => {
    if (typeof part === 'string')
        return part;
    if (!part.k)
        part.k = firstKey || '0';
    const trimmed = trimAllValues(part);
    return optimize ? removeEmptyValues(trimmed) : trimmed;
});

const getPartsFromString = (cache, text) => cache[text] || (cache[text] = parseRawText(text));

const getTextFromTranslationKey = (translations, key) => {
    var _a;
    key.split('.').forEach((k) => (translations = translations[k]));
    return (_a = translations) !== null && _a !== void 0 ? _a : key;
};
const getTranslateInstance = (locale, translations, formatters) => {
    const cache = {};
    const pluralRules = new Intl.PluralRules(locale);
    return (key, ...args) => translate(getPartsFromString(cache, getTextFromTranslationKey(translations, key)), pluralRules, formatters, args);
};
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any
function i18nObject(locale, translations, formatters = {}) {
    return createProxy(getTranslateInstance(locale, translations, formatters));
}
const createProxy = (fn, prefixKey, proxyObject = {}) => new Proxy((prefixKey ? fn.bind(null, prefixKey) : proxyObject), {
    get: (target, key) => !(target === proxyObject && key === 'then') && createProxy(fn, prefixKey ? `${prefixKey}.${key}` : key),
});

class I18nServiceRoot {
    constructor(baseLocale = '', getTranslationForLocale = () => ({}), initFormatters = () => ({})) {
        this.baseLocale = baseLocale;
        this.getTranslationForLocale = getTranslationForLocale;
        this.initFormatters = initFormatters;
        this._isLoadingLocale = false;
        this.currentLocale = null;
        this._LL = getFallbackProxy();
    }
    async initI18n(locale = this.baseLocale) {
        await this.setLocale(locale);
    }
    get isLoadingLocale() {
        return this._isLoadingLocale;
    }
    get LL() {
        return this._LL;
    }
    get locale() {
        return this.currentLocale;
    }
    async setLocale(newLocale) {
        const translation = this.getTranslationForLocale(newLocale);
        const formatters = this.initFormatters(newLocale);
        this._LL = i18nObject(newLocale, translation instanceof Promise ? await translation : translation, formatters instanceof Promise ? await formatters : formatters);
        this.currentLocale = newLocale;
    }
}

export { I18nServiceRoot };
//# sourceMappingURL=angular-service.mjs.map
