import type { Part, PluralPart } from './parser';
declare type TranslationParts<T = BaseTranslation> = {
    [key in keyof T]: Part[];
};
export declare type Cache<T = BaseTranslation> = TranslationParts<T>;
export declare type TranslationKey<T extends BaseTranslation> = keyof T;
declare const localized: unique symbol;
export declare type LocalizedString = string & {
    readonly [localized]: unknown;
};
declare type BaseTranslationFunction = (...args: Arguments) => LocalizedString;
export declare type TranslationFunctions<T = BaseTranslation> = {
    [key in keyof T]: T[key] extends string ? BaseTranslationFunction : TranslationFunctions<T[key]>;
};
export declare type Locale = string;
export declare type Arguments = any[];
export declare type BaseTranslation = {
    [key: string]: string | BaseTranslation;
};
export interface LocaleMapping {
    locale: string;
    translations: BaseTranslation;
}
export declare type FormatterFunction<T = any, U = unknown> = (value: T) => U;
export declare type BaseFormatters = {
    [formatter: string]: FormatterFunction;
};
export declare const isPluralPart: (part: Part) => part is PluralPart;
export declare const translate: (textParts: Part[], pluralRules: Intl.PluralRules, formatters: BaseFormatters, args: Arguments) => LocalizedString;
export {};
