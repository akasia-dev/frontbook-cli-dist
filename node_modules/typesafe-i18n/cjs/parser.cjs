"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseRawText = void 0;
const core_utils_1 = require("./core-utils.cjs");
// --------------------------------------------------------------------------------------------------------------------
// implementation -----------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------
const REGEX_BRACKETS_SPLIT = /({?{[^\\}]+}}?)/g;
const parseArgumentPart = (text) => {
    const [keyPart = '', ...formatterKeys] = text.split('|');
    const [keyWithoutType = '', type] = keyPart.split(':');
    const [key, isOptional] = keyWithoutType.split('?');
    return { k: key, i: type, n: isOptional === '', f: formatterKeys };
};
const parsePluralPart = (content, lastAccessor) => {
    let [key, values] = content.split(':');
    if (!values) {
        values = key;
        key = lastAccessor;
    }
    const entries = values.split('|');
    const [zero, one, two, few, many, rest] = entries;
    const nrOfEntries = entries.filter((entry) => entry !== undefined).length;
    if (nrOfEntries === 1) {
        return { k: key, r: zero };
    }
    if (nrOfEntries === 2) {
        return { k: key, o: zero, r: one };
    }
    if (nrOfEntries === 3) {
        return { k: key, z: zero, o: one, r: two };
    }
    return { k: key, z: zero, o: one, t: two, f: few, m: many, r: rest };
};
const parseRawText = (rawText, optimize = true, firstKey = '', lastKey = '') => rawText
    .split(REGEX_BRACKETS_SPLIT)
    .filter(Boolean)
    .map((part) => {
    if (!part.match(REGEX_BRACKETS_SPLIT)) {
        return part;
    }
    const content = part.substring(1, part.length - 1);
    if (content.startsWith('{') && content.endsWith('}')) {
        return parsePluralPart(content.substring(1, content.length - 1), lastKey);
    }
    const parsedPart = parseArgumentPart(content);
    lastKey = parsedPart.k || lastKey;
    !firstKey && (firstKey = lastKey);
    return parsedPart;
})
    .map((part) => {
    if (typeof part === 'string')
        return part;
    if (!part.k)
        part.k = firstKey || '0';
    const trimmed = (0, core_utils_1.trimAllValues)(part);
    return optimize ? (0, core_utils_1.removeEmptyValues)(trimmed) : trimmed;
});
exports.parseRawText = parseRawText;
//# sourceMappingURL=parser.js.map