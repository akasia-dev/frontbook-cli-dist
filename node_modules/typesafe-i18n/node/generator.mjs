#!/usr/bin/env node

import { watch } from 'chokidar';
import path, { resolve, dirname, join, sep } from 'path';
import ts from 'typescript';
import { promises } from 'fs';
import { pathToFileURL } from 'url';

let FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM, isTTY=true;
if (typeof process !== 'undefined') {
	({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env);
	isTTY = process.stdout && process.stdout.isTTY;
}

const $ = {
	enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== 'dumb' && (
		FORCE_COLOR != null && FORCE_COLOR !== '0' || isTTY
	),

	// modifiers
	reset: init(0, 0),
	bold: init(1, 22),
	dim: init(2, 22),
	italic: init(3, 23),
	underline: init(4, 24),
	inverse: init(7, 27),
	hidden: init(8, 28),
	strikethrough: init(9, 29),

	// colors
	black: init(30, 39),
	red: init(31, 39),
	green: init(32, 39),
	yellow: init(33, 39),
	blue: init(34, 39),
	magenta: init(35, 39),
	cyan: init(36, 39),
	white: init(37, 39),
	gray: init(90, 39),
	grey: init(90, 39),

	// background colors
	bgBlack: init(40, 49),
	bgRed: init(41, 49),
	bgGreen: init(42, 49),
	bgYellow: init(43, 49),
	bgBlue: init(44, 49),
	bgMagenta: init(45, 49),
	bgCyan: init(46, 49),
	bgWhite: init(47, 49)
};

function run(arr, str) {
	let i=0, tmp, beg='', end='';
	for (; i < arr.length; i++) {
		tmp = arr[i];
		beg += tmp.open;
		end += tmp.close;
		if (!!~str.indexOf(tmp.close)) {
			str = str.replace(tmp.rgx, tmp.close + tmp.open);
		}
	}
	return beg + str + end;
}

function chain(has, keys) {
	let ctx = { has, keys };

	ctx.reset = $.reset.bind(ctx);
	ctx.bold = $.bold.bind(ctx);
	ctx.dim = $.dim.bind(ctx);
	ctx.italic = $.italic.bind(ctx);
	ctx.underline = $.underline.bind(ctx);
	ctx.inverse = $.inverse.bind(ctx);
	ctx.hidden = $.hidden.bind(ctx);
	ctx.strikethrough = $.strikethrough.bind(ctx);

	ctx.black = $.black.bind(ctx);
	ctx.red = $.red.bind(ctx);
	ctx.green = $.green.bind(ctx);
	ctx.yellow = $.yellow.bind(ctx);
	ctx.blue = $.blue.bind(ctx);
	ctx.magenta = $.magenta.bind(ctx);
	ctx.cyan = $.cyan.bind(ctx);
	ctx.white = $.white.bind(ctx);
	ctx.gray = $.gray.bind(ctx);
	ctx.grey = $.grey.bind(ctx);

	ctx.bgBlack = $.bgBlack.bind(ctx);
	ctx.bgRed = $.bgRed.bind(ctx);
	ctx.bgGreen = $.bgGreen.bind(ctx);
	ctx.bgYellow = $.bgYellow.bind(ctx);
	ctx.bgBlue = $.bgBlue.bind(ctx);
	ctx.bgMagenta = $.bgMagenta.bind(ctx);
	ctx.bgCyan = $.bgCyan.bind(ctx);
	ctx.bgWhite = $.bgWhite.bind(ctx);

	return ctx;
}

function init(open, close) {
	let blk = {
		open: `\x1b[${open}m`,
		close: `\x1b[${close}m`,
		rgx: new RegExp(`\\x1b\\[${close}m`, 'g')
	};
	return function (txt) {
		if (this !== void 0 && this.has !== void 0) {
			!!~this.has.indexOf(open) || (this.has.push(open),this.keys.push(blk));
			return txt === void 0 ? this : $.enabled ? run(this.keys, txt+'') : txt+'';
		}
		return txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt+'') : txt+'';
	};
}

const getPermutations = (rest, permutedArray = []) => {
    if (rest.length === 0) {
        return [permutedArray];
    }
    return rest
        .map((_, i) => {
        const curr = rest.slice();
        const next = curr.splice(i, 1);
        return getPermutations(curr.slice(), permutedArray.concat(next));
    })
        .flat();
};
const parseTypescriptVersion = (versionMajorMinor) => {
    const [major, minor] = versionMajorMinor.split('.').map((item) => +item);
    return {
        major,
        minor,
    };
};
// --------------------------------------------------------------------------------------------------------------------
const sanitizeLocale = (locale) => locale.replace(/-/g, '_');
const prettify = (content) => content
    .replace(/^(\n)+/, '') // remove all new-lines on top of the file
    .replace(/\n\n+/g, '\n\n') // remove multiple new-lines
    .replace(/(\n)+$/, '\n'); // remove all multiple trailing new-lines
class TypesafeI18nParseError extends Error {
}
const colorMap = {
    warn: 'yellow',
    error: 'red',
};
const colorize = (logLevel, ...messages) => logLevel === 'info' ? messages : [$[colorMap[logLevel]]().bold(messages.join(' '))];
const log = (console, logLevel, ...messages) => console[logLevel](...colorize(logLevel, '[typesafe-i18n]', ...messages));
const throwError = (console, logLevel, ...messages) => {
    log(console, logLevel, ...messages);
    throw new TypesafeI18nParseError();
};
const createLogger = (console, throwOnError = false) => ({
    info: log.bind(null, console, 'info'),
    warn: log.bind(null, console, 'warn', 'WARNING:'),
    error: (throwOnError ? throwError : log).bind(null, console, 'error', 'ERROR:'),
});
const logger$1 = createLogger(console);

const filterDuplicates = (value, i, a) => a.findIndex((t) => t === value) === i;
const filterDuplicatesByKey = (key) => (value, i, a) => a.findIndex((t) => t[key] === value[key]) === i;

const isArray = (value) => Array.isArray(value);
const isArrayNotEmpty = (array) => !!(array === null || array === void 0 ? void 0 : array.length);

const isPropertyTrue = (property) => (value) => value[property] === true;

const isTruthy = (value) => !!value;
const isPropertyFalsy = (property) => (value) => !value[property];

const isNotUndefined = (value) => value !== undefined;

const isNotZero = (value) => value !== 0;

const isObject = (value) => value && typeof value === 'object';

const isString = (value) => typeof value === 'string';

const not = (filterFn) => (value, i, array) => !filterFn(value, i, array);

const sortASC = (a, b) => {
    if (a === b)
        return 0;
    if (a == null)
        return -1;
    if (b == null)
        return 1;
    return a < b ? -1 : 1;
};
const sortNumberASC = (a, b) => sortASC(a, b);
const sortStringASC = (a, b) => sortASC(a === null || a === void 0 ? void 0 : a.toLowerCase(), b === null || b === void 0 ? void 0 : b.toLowerCase());
const sortStringPropertyASC = (property) => ({ [property]: a }, { [property]: b }) => sortStringASC(a, b);

const uniqueArray = (array) => Array.from(new Set(array));

const OVERRIDE_WARNING = "// This file was auto-generated by 'typesafe-i18n'. Any manual changes will be overwritten.";
let outputFormat = 'TypeScript';
let tsVersion = parseTypescriptVersion('4.3');
const configureOutputHandler = (config, version) => {
    outputFormat = config.outputFormat;
    shouldGenerateJsDoc = outputFormat === 'JavaScript';
    fileEnding = shouldGenerateJsDoc ? '.js' : '.ts';
    fileEndingForTypesFile = shouldGenerateJsDoc ? '.d.ts' : '.ts';
    tsCheck = shouldGenerateJsDoc
        ? `
// @ts-check`
        : '';
    jsDocTsIgnore = shouldGenerateJsDoc
        ? `
	// @ts-ignore`
        : '';
    tsVersion = version;
    supportsTemplateLiteralTypes =
        shouldGenerateJsDoc || (tsVersion.major === 4 && tsVersion.minor >= 1) || tsVersion.major >= 5;
    supportsImportType = shouldGenerateJsDoc || (tsVersion.major === 3 && tsVersion.minor >= 8) || tsVersion.major >= 4;
    importTypeStatement = `import${supportsImportType ? ' type' : ''}`;
    importTypes = (from, ...types) => shouldGenerateJsDoc ? '' : `${importTypeStatement} { ${types.join(', ')} } from '${from}'`;
    type = (type) => (shouldGenerateJsDoc ? '' : `: ${type}`);
    typeCast = (type) => (shouldGenerateJsDoc ? '' : ` as ${type}`);
    generics = (...generics) => (shouldGenerateJsDoc ? '' : `<${generics.join(', ')}>`);
    jsDocImports = (...imports) => shouldGenerateJsDoc
        ? `
/**${imports.filter(isTruthy).map(({ from, type, alias }) => `
 * @typedef { import('${from}').${type} } ${alias || type}`)}
 */
`
        : '';
    jsDocFunction = (returnType, ...params) => shouldGenerateJsDoc
        ? `
/**${params.map(({ type, name }) => `
 * @param { ${type} } ${name}`)}
 * @return { ${returnType} }
 */`
        : '';
    jsDocType = (type) => (shouldGenerateJsDoc ? `/** @type { ${type} } */` : '');
    relativeFileImportPath = (fileName) => `${fileName.startsWith('..') ? '' : './'}${fileName}${config.esmImports ? '.js' : ''}`;
    relativeFolderImportPath = (folderName) => `${folderName.startsWith('..') ? '' : './'}${folderName}${config.esmImports ? '/index.js' : ''}`;
};
// --------------------------------------------------------------------------------------------------------------------
let supportsTemplateLiteralTypes;
let supportsImportType;
let shouldGenerateJsDoc;
let fileEnding;
let fileEndingForTypesFile;
let tsCheck;
let importTypeStatement;
let jsDocTsIgnore;
// --------------------------------------------------------------------------------------------------------------------
let importTypes;
let type;
let typeCast;
let generics;
let jsDocImports;
let jsDocFunction;
let jsDocType;
let relativeFileImportPath;
let relativeFolderImportPath;

const { readFile: read, readdir, writeFile, mkdir, stat, rm } = promises;
// --------------------------------------------------------------------------------------------------------------------
// implementation -----------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------
const readFile = async (file, createPath = false) => {
    var _a;
    try {
        if (createPath) {
            await createPathIfNotExits(resolve(dirname(file)));
        }
        return (_a = (await read(file))) === null || _a === void 0 ? void 0 : _a.toString();
    }
    catch (_e) {
        return createPath ? '' : readFile(file, true);
    }
};
const doesPathExist = async (path) => {
    try {
        await stat(path);
        return true;
    }
    catch (_e) {
        return false;
    }
};
const createPath = async (path) => {
    try {
        await mkdir(path, { recursive: true });
        return true;
    }
    catch (e) {
        logger$1.error(`createPath: ${path}`, e);
        return false;
    }
};
const createPathIfNotExits = async (path) => {
    const pathExists = await doesPathExist(path);
    if (!pathExists) {
        await createPath(path);
    }
};
const deleteFolderRecursive = async (path) => {
    try {
        await rm(path, { recursive: true });
        return true;
    }
    catch (e) {
        logger$1.error(`deleteFolderRecursive: ${path}`, e);
        return false;
    }
};
const getFileName = (path, file) => {
    const ext = file.endsWith(fileEnding) || file.endsWith(`${fileEnding}x`) || file.endsWith('.d.ts') ? '' : fileEnding;
    return join(path, `${file}${ext}`);
};
const writeNewFile = async (path, file, content) => {
    await createPathIfNotExits(path);
    writeFile(getFileName(path, file), content, { encoding: 'utf-8' });
    logger$1.info(`generated file: ${file}`);
};
const writeFileIfContainsChanges = async (path, file, content) => {
    const oldContent = await readFile(getFileName(path, file));
    if (oldContent === content)
        return;
    await writeNewFile(path, file, content);
};
const writeFileIfNotExists = async (path, file, content) => {
    if (await doesPathExist(getFileName(path, file)))
        return;
    await writeNewFile(path, file, content);
};
const getFiles = async (path, depth = 0) => {
    const entries = await readdir(path, { withFileTypes: true });
    const files = entries.filter((file) => !file.isDirectory()).map(({ name }) => ({ name, folder: '' }));
    const folders = entries.filter((folder) => folder.isDirectory());
    if (depth) {
        for (const folder of folders)
            files.push(...(await getFiles(`${resolve(path, folder.name)}/`, depth - 1)).map((a) => ({
                ...a,
                folder: folder.name,
            })));
    }
    return files;
};
const containsFolders = async (path) => {
    const entries = await readdir(path, { withFileTypes: true });
    return entries.some((folder) => folder.isDirectory());
};
const getDirectoryStructure = async (path) => {
    const entries = await readdir(path, { withFileTypes: true });
    const folders = entries.filter((folder) => folder.isDirectory());
    const promises = folders.map(({ name }) => new Promise((r) => getDirectoryStructure(resolve(path, name)).then((x) => r([name, x]))));
    return Object.fromEntries(await Promise.all(promises));
};
const isWindows = process.platform === 'win32';
const isEsm = (import.meta.url || '').endsWith('.mjs');
const importFile = async (file, outputError = true) => {
    var _a;
    if (file.endsWith('.json')) {
        const jsonFile = await readFile(file);
        return jsonFile ? JSON.parse(jsonFile) : undefined;
    }
    const importPath = isWindows && isEsm ? pathToFileURL(file).href : file;
    return (_a = (await import(importPath).catch((e) => {
        outputError && logger$1.error(`import failed for ${importPath}`, e);
        return null;
    }))) === null || _a === void 0 ? void 0 : _a.default;
};

const getAngularUtils = ({ utilFileName, formattersTemplateFileName, banner, typesFileName, }) => {
    return `${OVERRIDE_WARNING}${tsCheck}
${banner}

import { Injectable } from '@angular/core'
import { I18nServiceRoot } from 'typesafe-i18n/angular/angular-service'
import { initFormatters } from '${relativeFileImportPath(formattersTemplateFileName)}'
${importTypes(relativeFileImportPath(typesFileName), 'Locales', 'Translation', 'TranslationFunctions', 'Formatters')}
import { baseLocale, getTranslationForLocale } from '${relativeFileImportPath(utilFileName)}'

@Injectable({
	providedIn: 'root',
})
export class I18nService extends I18nServiceRoot<Locales, Translation, TranslationFunctions, Formatters> {
	constructor() {
		super(baseLocale, getTranslationForLocale, initFormatters)
	}
}
`;
};
const generateAngularAdapter = async (config) => {
    const { outputPath } = config;
    const nodeUtils = getAngularUtils(config);
    const fileName = config.adapterFileName || 'i18n.service';
    await writeFileIfContainsChanges(outputPath, fileName, prettify(nodeUtils));
};

const getNodeUtils = ({ utilFileName, loadLocalesAsync, banner }) => {
    return `${OVERRIDE_WARNING}${tsCheck}
${banner}

import { i18nString, i18nObject${loadLocalesAsync ? '' : ', i18n'} } from '${relativeFileImportPath(utilFileName)}';
${loadLocalesAsync
        ? ''
        : `
const L = i18n()
`}
export { i18nString, i18nObject${loadLocalesAsync ? '' : ', L'} }
${loadLocalesAsync
        ? ''
        : `
export default L
`}`;
};
const generateNodeAdapter = async (config) => {
    const { outputPath } = config;
    const nodeUtils = getNodeUtils(config);
    const fileName = config.adapterFileName || 'i18n-node';
    await writeFileIfContainsChanges(outputPath, fileName, prettify(nodeUtils));
};

const getReactUtils = ({ utilFileName, typesFileName, formattersTemplateFileName, banner, }) => {
    return `${OVERRIDE_WARNING}${tsCheck}
${banner}

${jsDocImports({
        from: 'typesafe-i18n/adapters/adapter-react',
        type: 'ReactInit<Locales, Translation, TranslationFunctions>',
        alias: 'ReactInit',
    }, { from: relativeFileImportPath(typesFileName), type: 'Locales' }, { from: relativeFileImportPath(typesFileName), type: 'Translation' }, { from: relativeFileImportPath(typesFileName), type: 'TranslationFunctions' }, { from: relativeFileImportPath(typesFileName), type: 'Formatters' })}

import { initI18nReact } from 'typesafe-i18n/adapters/adapter-react'
${importTypes(relativeFileImportPath(typesFileName), 'Locales', 'Translation', 'TranslationFunctions', 'Formatters')}
import { baseLocale, getTranslationForLocale } from '${relativeFileImportPath(utilFileName)}'
import { initFormatters } from '${relativeFileImportPath(formattersTemplateFileName)}'

${jsDocType('ReactInit')}
const { component: TypesafeI18n, context: I18nContext } = initI18nReact${generics('Locales', 'Translation', 'TranslationFunctions', 'Formatters')}(baseLocale, getTranslationForLocale, initFormatters)

export { I18nContext }

export default TypesafeI18n
`;
};
const generateReactAdapter = async (config) => {
    const { outputPath } = config;
    const reactUtils = getReactUtils(config);
    const fileName = config.adapterFileName || 'i18n-react';
    await writeFileIfContainsChanges(outputPath, `${fileName}${fileEnding}x`, prettify(reactUtils));
};

const getSvelteUtils = ({ baseLocale, formattersTemplateFileName, typesFileName, utilFileName, banner, }) => {
    return `${OVERRIDE_WARNING}${tsCheck}
${banner}

${jsDocImports({
        from: 'typesafe-i18n/adapters/adapter-svelte',
        type: 'SvelteStoreInit<Locales, Translation, TranslationFunctions>',
        alias: 'SvelteStoreInit',
    }, { from: relativeFileImportPath(typesFileName), type: 'Locales' }, { from: relativeFileImportPath(typesFileName), type: 'Translation' }, { from: relativeFileImportPath(typesFileName), type: 'TranslationFunctions' }, { from: relativeFileImportPath(typesFileName), type: 'Formatters' })}

import { getI18nSvelteStore } from 'typesafe-i18n/adapters/adapter-svelte';
${importTypes(relativeFileImportPath(typesFileName), 'Locales', 'Translation', 'TranslationFunctions', 'Formatters')}
import { getTranslationForLocale } from '${relativeFileImportPath(utilFileName)}'
import { initFormatters } from '${relativeFileImportPath(formattersTemplateFileName)}'

${jsDocType('SvelteStoreInit')}
const { initI18n: init, setLocale, isLoadingLocale, locale, LL } = getI18nSvelteStore${generics('Locales', 'Translation', 'TranslationFunctions', 'Formatters')}()

${jsDocFunction('Promise<void>', { type: 'Locales', name: 'locale' })}
const initI18n = (locale${type('Locales')} = '${baseLocale}') => init(locale, getTranslationForLocale, initFormatters)

export { initI18n, setLocale, isLoadingLocale, locale, LL }

export default LL
`;
};
const generateSvelteAdapter = async (config) => {
    const { outputPath } = config;
    const svelteUtils = getSvelteUtils(config);
    const fileName = config.adapterFileName || 'i18n-svelte';
    await writeFileIfContainsChanges(outputPath, fileName, prettify(svelteUtils));
};

const getFormattersTemplate = ({ typesFileName: typesFile, loadLocalesAsync }) => {
    const formattersInitializerType = `${loadLocalesAsync ? 'Async' : ''}FormattersInitializer`;
    return `${tsCheck}

${jsDocImports({ from: 'typesafe-i18n', type: 'FormattersInitializer<Locales, Formatters>', alias: 'FormattersInitializer' }, { from: relativeFileImportPath(typesFile), type: 'Locales' }, { from: relativeFileImportPath(typesFile), type: 'Formatters' })}

${importTypes('typesafe-i18n', formattersInitializerType)}
${importTypes(relativeFileImportPath(typesFile), 'Locales', 'Formatters')}

${jsDocFunction(loadLocalesAsync ? 'Promise<Formatters>' : 'Formatters', { type: 'Locales', name: 'locale' })}
export const initFormatters${type(`${formattersInitializerType}<Locales, Formatters>`)} = ${loadLocalesAsync ? 'async ' : ''}(locale${type('Locales')}) => {
	${jsDocType('Formatters')}
	const formatters${type('Formatters')} = {
		// add your formatter functions here
	}

	return formatters
}
`;
};
const generateFormattersTemplate = async (config, forceOverride) => {
    const { outputPath, formattersTemplateFileName: formattersTemplatePath } = config;
    const configTemplate = getFormattersTemplate(config);
    const write = forceOverride ? writeFileIfContainsChanges : writeFileIfNotExists;
    await write(outputPath, formattersTemplatePath, prettify(configTemplate));
};

// --------------------------------------------------------------------------------------------------------------------
const mapTranslationsToString = (translations, level = 1) => Object.entries(translations).map(mapTranslationToString.bind(null, level)).join('\n');
const mapTranslationToString = (level, [key, value]) => {
    const inset = new Array(level).fill(`	`).join('');
    if (isString(value))
        return `${inset}'${key}': '${value.replace(/'/g, "\\'")}',`;
    else
        return `${inset}'${key}': {
${mapTranslationsToString(value, level + 1)}
${inset}},`;
};
// --------------------------------------------------------------------------------------------------------------------
const getLocaleTemplate = ({ banner, typesFileName, esmImports }, locale, isBaseLocale, translations, editHint, showBanner) => {
    const typeToImport = isBaseLocale ? 'BaseTranslation' : 'Translation';
    const sanitizedLocale = sanitizeLocale(locale);
    const translationsMap = translations && mapTranslationsToString(translations);
    const defaultExport = shouldGenerateJsDoc && !esmImports ? 'module.exports =' : 'export default';
    const hint = editHint
        ? `	// ${editHint}
`
        : '';
    const bannerIfNeeded = showBanner
        ? `
${banner}`
        : '';
    return `${tsCheck}${bannerIfNeeded}
${importTypes(relativeFileImportPath(`../${typesFileName}`), typeToImport)}

${jsDocImports({ from: relativeFileImportPath(`../${typesFileName}`), type: typeToImport })}

${jsDocType(typeToImport)}
const ${sanitizedLocale}${type(typeToImport)} = {
${hint}${translationsMap}
}

${defaultExport} ${sanitizedLocale}
`;
};
const generateBaseLocaleTemplate = async (config, translations = undefined, editHint = '', showBanner = false) => generateLocaleTemplate(config, config.baseLocale, translations, editHint, showBanner);
const generateLocaleTemplate = async (config, locale, translations = undefined, editHint = '', showBanner = false) => {
    const { outputPath, baseLocale } = config;
    const isBaseLocale = baseLocale === locale;
    const localeTemplate = getLocaleTemplate(config, locale, isBaseLocale, translations, editHint, showBanner);
    await writeFileIfContainsChanges(join(outputPath, locale), `index${fileEnding}`, prettify(localeTemplate));
};

const getCustomTypesTemplate = ({ typesFileName: typesFile }) => {
    return `// use this file to export your custom types; these types will be imported by './${typesFile}${fileEndingForTypesFile}'`;
};
const generateCustomTypesTemplate = async (config, forceOverride) => {
    const { outputPath, typesTemplateFileName: typesTemplatePath } = config;
    const customTypesTemplate = getCustomTypesTemplate(config);
    const write = forceOverride ? writeFileIfContainsChanges : writeFileIfNotExists;
    await write(outputPath, `${typesTemplatePath}${fileEndingForTypesFile}`, prettify(customTypesTemplate));
};

// --------------------------------------------------------------------------------------------------------------------
// implementation -----------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------
const isPluralPart = (part) => !!(part.o || part.r);

const removeEmptyValues = (object) => Object.fromEntries(Object.entries(object)
    .map(([key, value]) => key !== 'i' && value && value != '0' && [key, value])
    .filter(Boolean));
const trimAllValues = (part) => Object.fromEntries(Object.keys(part).map((key) => {
    var _a;
    const val = part[key];
    return [
        key,
        Array.isArray(val) ? val.map((v) => v === null || v === void 0 ? void 0 : v.trim()) : val === !!val ? val : (_a = val) === null || _a === void 0 ? void 0 : _a.trim(),
    ];
}));
const partsAsStringWithoutTypes = (parts) => parts.map(partAsStringWithoutTypes).join('');
const partAsStringWithoutTypes = (part) => {
    var _a;
    if (typeof part === 'string') {
        return part;
    }
    if (isPluralPart(part)) {
        return `{{${[part.z, part.o, part.t, part.f, part.m, part.r].filter((value) => value !== undefined).join('|')}}}`;
    }
    return `{${part.k}${part.n ? '?' : ''}${((_a = part.f) === null || _a === void 0 ? void 0 : _a.length) ? `|${part.f.join('|')}` : ''}}`;
};

// --------------------------------------------------------------------------------------------------------------------
// implementation -----------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------
const REGEX_BRACKETS_SPLIT = /({?{[^\\}]+}}?)/g;
const parseArgumentPart = (text) => {
    const [keyPart = '', ...formatterKeys] = text.split('|');
    const [keyWithoutType = '', type] = keyPart.split(':');
    const [key, isOptional] = keyWithoutType.split('?');
    return { k: key, i: type, n: isOptional === '', f: formatterKeys };
};
const parsePluralPart = (content, lastAccessor) => {
    let [key, values] = content.split(':');
    if (!values) {
        values = key;
        key = lastAccessor;
    }
    const entries = values.split('|');
    const [zero, one, two, few, many, rest] = entries;
    const nrOfEntries = entries.filter((entry) => entry !== undefined).length;
    if (nrOfEntries === 1) {
        return { k: key, r: zero };
    }
    if (nrOfEntries === 2) {
        return { k: key, o: zero, r: one };
    }
    if (nrOfEntries === 3) {
        return { k: key, z: zero, o: one, r: two };
    }
    return { k: key, z: zero, o: one, t: two, f: few, m: many, r: rest };
};
const parseRawText = (rawText, optimize = true, firstKey = '', lastKey = '') => rawText
    .split(REGEX_BRACKETS_SPLIT)
    .filter(Boolean)
    .map((part) => {
    if (!part.match(REGEX_BRACKETS_SPLIT)) {
        return part;
    }
    const content = part.substring(1, part.length - 1);
    if (content.startsWith('{') && content.endsWith('}')) {
        return parsePluralPart(content.substring(1, content.length - 1), lastKey);
    }
    const parsedPart = parseArgumentPart(content);
    lastKey = parsedPart.k || lastKey;
    !firstKey && (firstKey = lastKey);
    return parsedPart;
})
    .map((part) => {
    if (typeof part === 'string')
        return part;
    if (!part.k)
        part.k = firstKey || '0';
    const trimmed = trimAllValues(part);
    return optimize ? removeEmptyValues(trimmed) : trimmed;
});

// --------------------------------------------------------------------------------------------------------------------
// implementation -----------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------
const wrapObjectType = (array, callback) => !array.length
    ? '{}'
    : `{${callback()}
}`;
const wrapUnionType = (array) => (!array.length ? ' never' : `${createUnionType(array)}`);
const createUnionType = (entries) => mapToString(entries, (locale) => `
	| '${locale}'`);
const NEW_LINE = `
`;
const NEW_LINE_INDENTED = `
	`;
const COMMA_SEPARATION = ', ';
const mapToString = (items, mappingFunction) => items.map(mappingFunction).join('');
const processNestedParsedResult = (items, mappingFunction) => NEW_LINE_INDENTED +
    mapToString(Object.entries(items), ([key, parsedResults]) => `'${key}': {${mapToString(parsedResults, mappingFunction)
        .split(/\r?\n/)
        .map((line) => `	${line}`)
        .join(NEW_LINE)}
	}`);
const getNestedKey = (key, parentKeys) => [...parentKeys, key].join('.');
const flattenToParsedResultEntry = (parsedResults) => parsedResults.flatMap((parsedResult) => isParsedResultEntry(parsedResult)
    ? parsedResult
    : Object.entries(parsedResult).flatMap(([_, nestedParsedResults]) => flattenToParsedResultEntry(nestedParsedResults)));
// --------------------------------------------------------------------------------------------------------------------
const parseTranslations = (translations, logger, parentKeys = []) => isObject(translations)
    ? Object.entries(translations).map(([key, text]) => {
        if (isString(text)) {
            return parseTranslationEntry([key, text], logger, parentKeys);
        }
        return { [key]: parseTranslations(text, logger, [...parentKeys, key]) };
    })
    : [];
const parseTranslationEntry = ([key, text], logger, parentKeys) => {
    const parsedParts = parseRawText(text, false);
    const textWithoutTypes = partsAsStringWithoutTypes(parsedParts);
    const parsedObjects = parsedParts.filter(isObject);
    const argumentParts = parsedObjects.filter(not(isPluralPart));
    const pluralParts = parsedObjects.filter(isPluralPart);
    const args = [];
    const types = {};
    argumentParts.forEach(({ k, n, i, f }) => {
        var _a, _b;
        args.push({ key: k, formatters: f, optional: n });
        types[k] = {
            types: uniqueArray([...(((_a = types[k]) === null || _a === void 0 ? void 0 : _a.types) || []), i]).filter(isNotUndefined),
            optional: ((_b = types[k]) === null || _b === void 0 ? void 0 : _b.optional) || n,
        };
    });
    pluralParts.forEach(({ k }) => {
        var _a;
        if (!((_a = types[k]) === null || _a === void 0 ? void 0 : _a.types.length)) {
            // if key has no types => add types that are valid for a PluralPart
            types[k] = { types: ['string', 'number', 'boolean'] };
            if (!args.find(({ key }) => key === k)) {
                // if only pluralPart exists => add it as argument
                args.push({ key: k, formatters: [], pluralOnly: true });
            }
        }
    });
    // add 'unknown' if argument has no type
    Object.keys(types).forEach((key) => {
        var _a, _b;
        if (!((_a = types[key]) === null || _a === void 0 ? void 0 : _a.types.length)) {
            types[key] = { types: ['unknown'], optional: (_b = types[key]) === null || _b === void 0 ? void 0 : _b.optional };
        }
    });
    args.sort(sortStringPropertyASC('key'));
    const isValid = validateTranslation(key, types, logger);
    if (!isValid)
        return null;
    return removeEmptyValues({ key, text, textWithoutTypes, args, types, parentKeys });
};
const validateTranslation = (key, types, logger) => {
    const base = `translation '${key}' =>`;
    if (key.includes('.')) {
        logger.error(`${base} key can't contain the '.' character. Please remove it. If you want to nest keys, you should look at https://github.com/ivanhofer/typesafe-i18n#nested-translations`);
        return false;
    }
    const argKeys = Object.keys(types).sort(sortStringASC);
    if (isArrayNotEmpty(argKeys) && !isNaN(+argKeys[0])) {
        let expectedKey = '0';
        for (const argKey of argKeys) {
            if (argKey !== expectedKey) {
                const info = isNaN(+argKey)
                    ? `You can't mix keyed and index-based arguments.`
                    : `Make sure to not skip an index for your arguments.`;
                logger.error(`${base} argument {${expectedKey}} expected, but {${argKey}} found.`, info);
                return false;
            }
            expectedKey = (+argKey + 1).toString();
        }
    }
    return true;
};
// --------------------------------------------------------------------------------------------------------------------
const createLocalesType = (locales, baseLocale) => {
    const usedLocales = (locales === null || locales === void 0 ? void 0 : locales.length) ? locales : [baseLocale];
    return `export type Locales =${wrapUnionType(usedLocales)}`;
};
// --------------------------------------------------------------------------------------------------------------------
const BASE_TYPES = [
    'boolean',
    'number',
    'bigint',
    'string',
    'Date',
    'object',
    'undefined',
    'null',
    'unknown',
    'LocalizedString',
].flatMap((t) => [t, `${t}[]`]);
const isParsedResultEntry = (entry) => isArray(entry.parentKeys) && isObject(entry.types);
const extractTypes = (parsedTranslations) => parsedTranslations.flatMap((parsedTranslation) => {
    if (isParsedResultEntry(parsedTranslation)) {
        return Object.values(parsedTranslation.types)
            .map(({ types }) => types)
            .flat();
    }
    return extractTypes(Object.values(parsedTranslation).flat());
});
const createTypeImports = (parsedTranslations, typesTemplatePath) => {
    const types = extractTypes(parsedTranslations).filter(filterDuplicates);
    const externalTypes = Array.from(types)
        .filter((type) => !BASE_TYPES.includes(type))
        .sort(sortStringASC);
    return !externalTypes.length
        ? ''
        : `
${importTypeStatement} { ${externalTypes.join(COMMA_SEPARATION)} } from './${typesTemplatePath.replace('.ts', '')}'
`;
};
// --------------------------------------------------------------------------------------------------------------------
const createJsDocsMapping = (parsedTranslations) => {
    const map = {};
    flattenToParsedResultEntry(parsedTranslations).forEach((parsedResultEntry) => {
        const { key, textWithoutTypes, types, args, parentKeys } = parsedResultEntry;
        const nestedKey = getNestedKey(key, parentKeys);
        map[nestedKey] = {
            text: textWithoutTypes,
            types,
            pluralOnlyArgs: args.filter(isPropertyTrue('pluralOnly')).map(({ key }) => key),
        };
    });
    return map;
};
const createJsDocsString = ({ text, types, pluralOnlyArgs } = {}, renderTypes = false, renderPluralOnlyArgs = true) => {
    const renderedTypes = renderTypes
        ? `${Object.entries(types || {})
            .filter(({ '0': key }) => renderPluralOnlyArgs || !pluralOnlyArgs.includes(key))
            .sort(sortStringPropertyASC('0'))
            .map(createJsDocsParamString)
            .join('')}`
        : '';
    return (text === null || text === void 0 ? void 0 : text.length) + renderedTypes.length
        ? `/**
	 * ${text}${renderedTypes}
	 */
	`
        : '';
};
const createJsDocsParamString = ([paramName, { types, optional }]) => `
	 * @param {${types.join(' | ')}} ${optional ? `[${paramName}]` : paramName}`;
// --------------------------------------------------------------------------------------------------------------------
const createTranslationType = (parsedTranslations, jsDocInfo, paramTypesToGenerate) => `export type Translation = ${wrapObjectType(parsedTranslations, () => mapToString(parsedTranslations, (parsedResultEntry) => createTranslationTypeEntry(parsedResultEntry, jsDocInfo, paramTypesToGenerate)))}`;
const createTranslationTypeEntry = (resultEntry, jsDocInfo, paramTypesToGenerate) => {
    if (isParsedResultEntry(resultEntry)) {
        const { key, args, parentKeys } = resultEntry;
        const nestedKey = getNestedKey(key, parentKeys);
        const jsDocString = createJsDocsString(jsDocInfo[nestedKey], true, false);
        const translationType = generateTranslationType(paramTypesToGenerate, args);
        return `
	${jsDocString}'${key}': ${translationType}`;
    }
    return processNestedParsedResult(resultEntry, (parsedResultEntry) => createTranslationTypeEntry(parsedResultEntry, jsDocInfo, paramTypesToGenerate));
};
const REGEX_BRACKETS = /[{}]/g;
const generateTranslationType = (paramTypesToGenerate, args) => {
    const argStrings = args
        .filter(isPropertyFalsy('pluralOnly'))
        .map(({ key, optional, formatters }) => partAsStringWithoutTypes({ k: key, n: optional, f: formatters }).replace(REGEX_BRACKETS, ''));
    const nrOfArgs = argStrings.length;
    paramTypesToGenerate.push(nrOfArgs);
    return supportsTemplateLiteralTypes && nrOfArgs
        ? `RequiredParams${nrOfArgs}<${argStrings.map((arg) => `'${arg}'`).join(COMMA_SEPARATION)}>`
        : 'string';
};
// --------------------------------------------------------------------------------------------------------------------
const createParamsType = (paramTypesToGenerate) => {
    const filteredParamTypes = paramTypesToGenerate.filter(filterDuplicates).filter(isNotZero).sort(sortNumberASC);
    if (filteredParamTypes.length === 0) {
        return '';
    }
    const result = filteredParamTypes.map(generateParamType);
    const baseTypes = result.map(([baseType]) => baseType);
    const permutationTypes = result.map(([_, permutationTypes]) => permutationTypes);
    return `
type Param<P extends string> = \`{\${P}}\`
${baseTypes === null || baseTypes === void 0 ? void 0 : baseTypes.join(NEW_LINE)}
${permutationTypes === null || permutationTypes === void 0 ? void 0 : permutationTypes.join(NEW_LINE)}
`;
};
const generateParamType = (nrOfParams) => {
    const args = new Array(nrOfParams).fill(0).map((_, i) => i + 1);
    const baseType = generateBaseType(args);
    const permutationType = generatePermutationType(args);
    return [baseType, permutationType];
};
const generateBaseType = (args) => {
    const generics = args.map((i) => `P${i} extends string`).join(COMMA_SEPARATION);
    const params = args.map((i) => `\${Param<P${i}>}`).join(`\${string}`);
    return `
type Params${args.length}<${generics}> =
	\`\${string}${params}\${string}\``;
};
const generatePermutationType = (args) => {
    const l = args.length;
    const generics = args.map((i) => `P${i} extends string`).join(COMMA_SEPARATION);
    const permutations = getPermutations(args);
    return `
type RequiredParams${l}<${generics}> =${mapToString(permutations, (permutation) => `
	| Params${l}<${permutation.map((p) => `P${p}`).join(COMMA_SEPARATION)}>`)}`;
};
// --------------------------------------------------------------------------------------------------------------------
const createTranslationsArgsType = (parsedTranslations, jsDocInfo) => `export type TranslationFunctions = ${wrapObjectType(parsedTranslations, () => mapToString(parsedTranslations, (translation) => createTranslationArgsType(translation, jsDocInfo)))}`;
const createTranslationArgsType = (parsedResult, jsDocInfo) => {
    if (isParsedResultEntry(parsedResult)) {
        const { key, args, types, parentKeys } = parsedResult;
        const nestedKey = getNestedKey(key, parentKeys);
        const jsDocString = createJsDocsString(jsDocInfo[nestedKey]);
        return `
	${jsDocString}'${key}': (${mapTranslationArgs(args, types)}) => LocalizedString`;
    }
    return processNestedParsedResult(parsedResult, (parsedResultEntry) => createTranslationArgsType(parsedResultEntry, jsDocInfo));
};
const mapTranslationArgs = (args, types) => {
    var _a;
    if (!args.length)
        return '';
    const uniqueArgs = args.filter(filterDuplicatesByKey('key'));
    const arg = (_a = uniqueArgs[0]) === null || _a === void 0 ? void 0 : _a.key;
    const isKeyed = isNaN(+arg);
    const prefix = (isKeyed && 'arg: { ') || '';
    const postfix = (isKeyed && ' }') || '';
    const argPrefix = (!isKeyed && 'arg') || '';
    return (prefix +
        uniqueArgs
            .map(({ key, optional }) => { var _a; return `${argPrefix}${key}${optional ? '?' : ''}: ${(_a = types[key]) === null || _a === void 0 ? void 0 : _a.types.join(' | ')}`; })
            .join(COMMA_SEPARATION) +
        postfix);
};
// --------------------------------------------------------------------------------------------------------------------
const getUniqueFormatters = (parsedTranslations) => {
    const map = {};
    flattenToParsedResultEntry(parsedTranslations).forEach((parsedResult) => {
        const { types, args } = parsedResult;
        args.forEach(({ key, formatters }) => (formatters || []).forEach((formatter) => { var _a; return (map[formatter] = [...(map[formatter] || []), ...(((_a = types[key]) === null || _a === void 0 ? void 0 : _a.types) || [])]); }));
    });
    return Object.entries(map).sort(sortStringPropertyASC('0'));
};
const createFormattersType = (parsedTranslations) => {
    const formatters = getUniqueFormatters(parsedTranslations);
    return `export type Formatters = ${wrapObjectType(formatters, () => mapToString(formatters, ([key, types]) => `
	'${key}': (value: ${uniqueArray(types).join(' | ')}) => unknown`))}`;
};
// --------------------------------------------------------------------------------------------------------------------
const getTypes = ({ translations, baseLocale, locales, typesTemplateFileName, banner }, logger) => {
    const parsedTranslations = parseTranslations(translations, logger).filter(isTruthy);
    const typeImports = createTypeImports(parsedTranslations, typesTemplateFileName);
    const localesType = createLocalesType(locales, baseLocale);
    const jsDocsInfo = createJsDocsMapping(parsedTranslations);
    const paramTypesToGenerate = [];
    const translationType = createTranslationType(parsedTranslations, jsDocsInfo, paramTypesToGenerate);
    const paramsType = supportsTemplateLiteralTypes ? createParamsType(paramTypesToGenerate) : '';
    const imports = parsedTranslations.length
        ? `${importTypeStatement} { LocalizedString } from 'typesafe-i18n'
`
        : '';
    const translationArgsType = createTranslationsArgsType(parsedTranslations, jsDocsInfo);
    const formattersType = createFormattersType(parsedTranslations);
    const type = `${OVERRIDE_WARNING}
${banner}
${importTypeStatement} { BaseTranslation as BaseTranslationType } from 'typesafe-i18n'
${imports}${typeImports}
export type BaseTranslation = BaseTranslationType
export type BaseLocale = '${baseLocale}'

${localesType}

${translationType}

${translationArgsType}

${formattersType}

${paramsType}`;
    return [type, !!typeImports];
};
const generateTypes = async (config, logger) => {
    const { outputPath, typesFileName } = config;
    const [types, hasCustomTypes] = getTypes(config, logger);
    await writeFileIfContainsChanges(outputPath, `${typesFileName}${fileEndingForTypesFile}`, prettify(types));
    return hasCustomTypes;
};

const getLocalesTranslationRowAsync = (locale) => {
    const sanitizedLocale = sanitizeLocale(locale);
    const needsEscaping = locale !== sanitizedLocale;
    const wrappedLocale = needsEscaping ? `'${locale}'` : locale;
    return `
	${wrappedLocale}: () => import('${relativeFolderImportPath(locale)}'),`;
};
const getAsyncCode = ({ locales }) => {
    const localesTranslationLoaders = locales.map(getLocalesTranslationRowAsync).join('');
    return `
${jsDocType('Record<Locales, () => Promise<any>>')}
const localeTranslationLoaders = {${localesTranslationLoaders}
}

${jsDocFunction('Promise<Translation>', { type: 'Locales', name: 'locale' })}
export const getTranslationForLocale = async (locale${type('Locales')}) => (await (localeTranslationLoaders[locale] || localeTranslationLoaders[baseLocale])()).default${typeCast('Translation')}

${jsDocFunction('Promise<TranslationFunctions>', { type: 'Locales', name: 'locale' })}
export const i18nObject = (locale${type('Locales')}) => i18nObjectLoaderAsync${generics('Locales', 'Translation', 'TranslationFunctions', 'Formatters')}(locale, getTranslationForLocale, initFormatters)
`;
};
const getLocalesTranslationRowSync = (locale, baseLocale) => {
    const sanitizedLocale = sanitizeLocale(locale);
    const needsEscaping = locale !== sanitizedLocale;
    const postfix = locale === baseLocale
        ? `: ${sanitizedLocale}${typeCast('Translation')}`
        : needsEscaping
            ? `: ${sanitizedLocale}`
            : '';
    const wrappedLocale = needsEscaping ? `'${locale}'` : locale;
    return `${locale === baseLocale ? jsDocTsIgnore : ''}
	${wrappedLocale}${postfix},`;
};
const getSyncCode = ({ baseLocale, locales }) => {
    const localesImports = locales
        .map((locale) => `
import ${sanitizeLocale(locale)} from '${relativeFolderImportPath(locale)}'`)
        .join('');
    const localesTranslations = locales.map((locale) => getLocalesTranslationRowSync(locale, baseLocale)).join('');
    return `${localesImports}

${jsDocType('LocaleTranslations')}
const localeTranslations${type('LocaleTranslations<Locales, Translation>')} = {${localesTranslations}
}

${jsDocFunction('Translation', { type: 'Locales', name: 'locale' })}
export const getTranslationForLocale = (locale${type('Locales')}) => localeTranslations[locale] || localeTranslations[baseLocale]

${jsDocFunction('TranslationFunctions', { type: 'Locales', name: 'locale' })}
export const i18nObject = (locale${type('Locales')}) => i18nObjectLoader${generics('Locales', 'Translation', 'TranslationFunctions', 'Formatters')}(locale, getTranslationForLocale, initFormatters)

${jsDocFunction('LocaleTranslationFunctions')}
export const i18n = () => initI18n${generics('Locales', 'Translation', 'TranslationFunctions', 'Formatters')}(getTranslationForLocale, initFormatters)
`;
};
const getUtil = (config) => {
    const { typesFileName, formattersTemplateFileName: formattersTemplatePath, loadLocalesAsync, baseLocale, locales, banner, } = config;
    const dynamicImports = loadLocalesAsync
        ? `import { i18nString as initI18nString, i18nObjectLoaderAsync } from 'typesafe-i18n'`
        : `${importTypes('typesafe-i18n', 'LocaleTranslations')}
import { i18nString as initI18nString, i18nObjectLoader, i18n as initI18n } from 'typesafe-i18n'`;
    const dynamicCode = loadLocalesAsync ? getAsyncCode(config) : getSyncCode(config);
    const localesEnum = `
${jsDocType('Locales[]')}
export const locales${type('Locales[]')} = [${locales.map((locale) => `
	'${locale}'`)}
]`;
    return `${OVERRIDE_WARNING}${tsCheck}
${banner}

${jsDocImports({ from: 'typesafe-i18n', type: 'TranslateByString' }, { from: 'typesafe-i18n', type: 'LocaleTranslations<Locales, Translation>', alias: 'LocaleTranslations' }, !loadLocalesAsync ? { from: 'typesafe-i18n', type: 'LocaleTranslationFunctions' } : undefined, { from: 'typesafe-i18n/detectors', type: 'LocaleDetector' }, { from: relativeFileImportPath(typesFileName), type: 'Locales' }, { from: relativeFileImportPath(typesFileName), type: 'Translation' }, { from: relativeFileImportPath(typesFileName), type: 'TranslationFunctions' })}

${dynamicImports}
${importTypes(relativeFileImportPath(typesFileName), 'Translation', 'TranslationFunctions', 'Formatters', 'Locales')}
${importTypes('typesafe-i18n/detectors', 'LocaleDetector')}
import { detectLocale as detectLocaleFn } from 'typesafe-i18n/detectors'
import { initFormatters } from '${relativeFileImportPath(formattersTemplatePath)}'

${jsDocType('Locales')}
export const baseLocale${type('Locales')} = '${baseLocale}'

${localesEnum}
${dynamicCode}

${jsDocFunction(loadLocalesAsync ? 'Promise<TranslateByString>' : 'TranslateByString', {
        type: 'Locales',
        name: 'locale',
    })}
export const i18nString = ${loadLocalesAsync ? 'async ' : ''}(locale${type('Locales')}) => initI18nString${generics('Locales', 'Formatters')}(locale, ${loadLocalesAsync ? 'await ' : ''}initFormatters(locale))

${jsDocFunction('Locales', { type: 'LocaleDetector[]', name: 'detectors' })}
export const detectLocale = (...detectors${type('LocaleDetector[]')}) => detectLocaleFn${generics('Locales')}(baseLocale, locales, ...detectors)
`;
};
const generateUtil = async (config) => {
    const { outputPath, utilFileName: utilFile } = config;
    const util = getUtil(config);
    await writeFileIfContainsChanges(outputPath, utilFile, prettify(util));
};

// --------------------------------------------------------------------------------------------------------------------
// implementation -----------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------
const readConfig = async (config) => {
    const generatorConfig = {
        ...config,
        ...((await importFile(path.resolve('.typesafe-i18n.json'), false)) || {}),
    };
    // remove "$schema" property
    return Object.fromEntries(Object.entries(generatorConfig).filter(([key]) => key !== '$schema'));
};
const getConfigWithDefaultValues = async (config) => ({
    baseLocale: 'en',
    locales: [],
    tempPath: './node_modules/typesafe-i18n/temp-output/',
    outputPath: './src/i18n/',
    outputFormat: 'TypeScript',
    typesFileName: 'i18n-types',
    utilFileName: 'i18n-util',
    formattersTemplateFileName: 'formatters',
    typesTemplateFileName: 'custom-types',
    esmImports: false,
    loadLocalesAsync: true,
    generateOnlyTypes: false,
    banner: '/* eslint-disable */',
    ...(await readConfig(config)),
});
const generateDictionaryFiles = async (config = {}, forceOverride) => {
    if (!forceOverride) {
        return;
    }
    const dummyTranslations = {
        en: 'Hi {name}! Please leave a star if you like this project: https://github.com/ivanhofer/typesafe-i18n',
        de: 'Hallo {name}! Bitte hinterlasse einen Stern, wenn dir das Projekt gefällt: https://github.com/ivanhofer/typesafe-i18n',
    };
    const primaryLocale = config.baseLocale.startsWith('de') ? 'de' : 'en';
    const secondaryLocale = primaryLocale === 'de' ? 'en' : 'de';
    await generateBaseLocaleTemplate(config, {
        HI: dummyTranslations[primaryLocale].replace('{name}', '{name:string}'),
    }, 'TODO: your translations go here');
    await generateLocaleTemplate(config, secondaryLocale, {
        HI: dummyTranslations[secondaryLocale],
    }, 'this is an example Translation, just rename or delete this folder if you want');
};
const generate = async (translations, config = {}, version, logger = logger$1, forceOverride = false) => {
    configureOutputHandler(config, version);
    await generateDictionaryFiles(config, forceOverride);
    const hasCustomTypes = await generateTypes({ ...config, translations }, logger);
    if (!config.generateOnlyTypes) {
        await generateFormattersTemplate(config, forceOverride);
        if (hasCustomTypes) {
            await generateCustomTypesTemplate(config, forceOverride);
        }
        await generateUtil(config);
    }
    switch (config.adapter) {
        case 'angular':
            await generateAngularAdapter(config);
            break;
        case 'node':
            await generateNodeAdapter(config);
            break;
        case 'react':
            await generateReactAdapter(config);
            break;
        case 'svelte':
            await generateSvelteAdapter(config);
            break;
    }
};

/**
 * looks for the location of the compiled 'index.js' file
 * if the 'index.ts' file imports something from outside it's directory, we need to find the correct path to the base location file
 */
const detectLocationOfCompiledBaseTranslation = async (outputPath, locale, tempPath) => {
    if (!containsFolders(tempPath))
        return '';
    const directory = await getDirectoryStructure(tempPath);
    // contains the path from <root> to base locale file
    const outputPathParts = resolve(outputPath, locale).replace(resolve(), '').split(sep).filter(isTruthy);
    for (let i = 0; i < outputPathParts.length; i++) {
        const part = outputPathParts[i];
        const subDirectory = directory[part];
        if (subDirectory) {
            let outputPathPartsRest = [...outputPathParts].slice(i + 1);
            let isPathValid = true;
            let subDirectoryOfCurrentSection = subDirectory;
            const subPaths = [part];
            while (isPathValid && outputPathPartsRest.length) {
                // we need to find the full matching path
                // e.g. `src/path/i18n/en` is invalid if the base locale is located inside `src/i18n/en`
                const subSubDirectoryOfCurrentSection = subDirectoryOfCurrentSection[outputPathPartsRest[0]];
                if (subSubDirectoryOfCurrentSection) {
                    subPaths.push(outputPathPartsRest[0]);
                    outputPathPartsRest = outputPathPartsRest.slice(1);
                    subDirectoryOfCurrentSection = subSubDirectoryOfCurrentSection;
                }
                else {
                    isPathValid = false;
                }
            }
            if (isPathValid) {
                i += outputPathPartsRest.length;
                return [...subPaths, ''].join('/');
            }
        }
    }
    return '';
};
const transpileTypescriptFiles = async (outputPath, languageFilePath, locale, tempPath) => {
    const program = ts.createProgram([languageFilePath], { outDir: tempPath, allowJs: true });
    program.emit();
    const baseTranslationPath = await detectLocationOfCompiledBaseTranslation(outputPath, locale, tempPath);
    return resolve(tempPath, `${baseTranslationPath}index.js`);
};
const parseLanguageFile = async (outputPath, locale, tempPath) => {
    const originalPath = resolve(outputPath, locale, `index${fileEnding}`);
    if (!(await doesPathExist(originalPath))) {
        logger$1.info(`could not load base locale file '${locale}'`);
        return null;
    }
    await createPathIfNotExits(tempPath);
    const importPath = await transpileTypescriptFiles(outputPath, originalPath, locale, tempPath);
    if (!importPath) {
        return null;
    }
    const languageImport = await importFile(importPath);
    await deleteFolderRecursive(tempPath);
    if (!languageImport) {
        logger$1.error(`could not read default export from language file '${locale}'`);
        return null;
    }
    return languageImport;
};
const getAllLanguages = async (path) => {
    const files = await getFiles(path, 1);
    return files.filter(({ folder, name }) => folder && name === `index${fileEnding}`).map(({ folder }) => folder);
};

let logger;
let first = true;
const getDefaultExport = (languageFile) => {
    const keys = Object.keys(languageFile);
    if (keys.includes('__esModule') || (keys.length === 1 && keys.includes('default'))) {
        languageFile = languageFile.default;
    }
    return languageFile;
};
const parseAndGenerate = async (config, version) => {
    if (first) {
        first = false;
    }
    else {
        logger.info('files were modified => looking for changes ...');
    }
    const { baseLocale: locale, tempPath, outputPath } = config;
    const locales = await getAllLanguages(outputPath);
    const firstLaunchOfGenerator = !locales.length;
    const languageFile = (locale && (await parseLanguageFile(outputPath, locale, resolve(tempPath, `${debounceCounter}`)))) || {};
    const translations = getDefaultExport(languageFile);
    await generate(translations, { ...config, baseLocale: locale, locales }, version, logger, firstLaunchOfGenerator);
    if (firstLaunchOfGenerator) {
        let message = 'Visit https://github.com/ivanhofer/typesafe-i18n#options and configure `typesafe-i18n` depending on your project-setup.';
        if (!config.adapter) {
            message += " You probably want to set at least the 'adapter' option.";
        }
        logger.warn(message);
    }
    logger.info('... all files are up to date');
};
let debounceCounter = 0;
const debounce = (callback) => setTimeout((i) => {
    i === debounceCounter && callback();
}, 100, ++debounceCounter);
const startGenerator = async (config, watchFiles = true) => {
    logger = createLogger(console, !watchFiles);
    const parsedConfig = await readConfig(config);
    const configWithDefaultValues = await getConfigWithDefaultValues(parsedConfig);
    const { outputPath } = configWithDefaultValues;
    const version = parseTypescriptVersion(ts.versionMajorMinor);
    configureOutputHandler(configWithDefaultValues, version);
    const onChange = parseAndGenerate.bind(null, configWithDefaultValues, version);
    await createPathIfNotExits(outputPath);
    watchFiles && watch(outputPath).on('all', () => debounce(onChange));
    logger.info(`generating files for ${shouldGenerateJsDoc ? 'JavaScript with JSDoc notation' : `TypeScript version: '${ts.versionMajorMinor}.x'`}`);
    logger.info(`options:`, parsedConfig);
    watchFiles && logger.info(`watcher started in: '${outputPath}'`);
    if (!watchFiles) {
        await onChange();
        logger.info(`generating files completed`);
    }
};

const allowedArguments = ['--no-watch'];
const [, , ...args] = process.argv;
args.forEach((arg) => {
    if (!allowedArguments.includes(arg)) {
        logger$1.error(`unknown argument '${arg}'`);
        logger$1.info(`allowed arguments: ${allowedArguments.map((arg) => `'${arg}'`).join(', ')}`);
        process.exit(1);
    }
});
const watchFiles = !args.includes('--no-watch');
startGenerator(undefined, watchFiles);
//# sourceMappingURL=generator.mjs.map
